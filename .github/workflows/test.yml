name: Test Suite (Backend Unit Tests & Flutter Integration Tests)

on:
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  backend-tests:
    name: Backend Unit Tests & Coverage
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        working-directory: ./api
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      
      - name: Run backend unit tests with coverage
        working-directory: .
        run: |
          pytest unitTest -v \
            --cov=routers.firefighters \
            --cov=routers.stations \
            --cov=routers.inspections \
            --cov-report=xml:coverage.xml \
            --cov-report=html:htmlcov \
            --cov-report=term-missing \
            --cov-branch
        env:
          PYTHONPATH: ${{ github.workspace }}/api
      
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage.xml
            htmlcov/
          retention-days: 30
      
      - name: Display coverage summary
        run: |
          echo "### Backend Unit Test Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          coverage report -m || echo "Coverage report not available" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  integration-tests:
    name: Flutter Integration Tests
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpassword
          MYSQL_DATABASE: gearmate
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping --silent"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install Python dependencies
        working-directory: ./api
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Wait for MySQL to be ready
        run: |
          for i in {1..30}; do
            if mysqladmin ping -h 127.0.0.1 -P 3306 -u root -ptestpassword --silent; then
              echo "MySQL is ready!"
              break
            fi
            echo "Waiting for MySQL... ($i/30)"
            sleep 2
          done
      
      - name: Initialize database with schema and test data
        working-directory: ./api
        run: |
          # Skip DROP DATABASE command since MySQL service already created it
          tail -n +2 gearmateDB.sql | mysql -h 127.0.0.1 -P 3306 -u root -ptestpassword gearmate
          echo "Database initialized successfully"
      
      - name: Create .env file for API
        working-directory: ./api
        run: |
          cat > .env << EOF
          HOST=0.0.0.0
          PORT=8000
          DEBUG=True
          DB_USER=root
          DB_PASSWORD=testpassword
          DB_HOST=127.0.0.1
          DB_PORT=3306
          DB_NAME=gearmate
          EOF
      
      - name: Start FastAPI backend
        working-directory: ./api
        run: |
          python -m uvicorn main:app --host 0.0.0.0 --port 8000 &
          echo $! > api.pid
          echo "Backend API started with PID $(cat api.pid)"
      
      - name: Wait for API to be ready
        run: |
          echo "Waiting for API health check..."
          for i in {1..30}; do
            if curl -f http://localhost:8000/health > /dev/null 2>&1; then
              echo "API is ready!"
              curl http://localhost:8000/health
              break
            fi
            echo "Waiting for API... ($i/30)"
            sleep 2
          done
          # Verify API is actually responding
          curl -f http://localhost:8000/health || (echo "API health check failed" && exit 1)
      
      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.24.x'
          channel: 'stable'
          cache: true
      
      - name: Flutter doctor
        run: flutter doctor -v
      
      - name: Install Flutter dependencies
        working-directory: ./client
        run: flutter pub get
      
      - name: Update integration tests to use localhost
        working-directory: ./client
        run: |
          # Create a backup and update API URLs for CI environment
          find integration_test -type f -name "*.dart" -exec sed -i.bak 's|http://10.0.2.2:8000|http://localhost:8000|g' {} \;
          find integration_test -type f -name "*.dart" -exec sed -i.bak 's|http://127.0.0.1:8000|http://localhost:8000|g' {} \;
          echo "Updated API URLs to use localhost for CI"
      
      - name: Run Flutter integration tests
        working-directory: ./client
        run: |
          flutter test --dart-define=DISABLE_NOTIFICATIONS=true integration_test
        env:
          FLUTTER_TEST_DEVICE_ID: linux
      
      - name: Stop backend API
        if: always()
        working-directory: ./api
        run: |
          if [ -f api.pid ]; then
            kill $(cat api.pid) || true
            rm api.pid
          fi
      
      - name: Upload integration test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: |
            client/test-results/
            client/screenshots/
          retention-days: 7

  coverage-comment:
    name: Post Coverage Report to PR
    runs-on: ubuntu-latest
    needs: [backend-tests, integration-tests]
    if: github.event_name == 'pull_request'
    permissions:
      pull-requests: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
      
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install coverage tools
        run: pip install coverage
      
      - name: Parse coverage and create comment
        id: coverage
        run: |
          # Parse the XML coverage report
          python << 'EOF'
          import xml.etree.ElementTree as ET
          import os
          
          tree = ET.parse('coverage.xml')
          root = tree.getroot()
          
          # Extract overall coverage
          overall_line_rate = float(root.attrib.get('line-rate', 0)) * 100
          overall_branch_rate = float(root.attrib.get('branch-rate', 0)) * 100
          
          # Extract per-file coverage
          packages = root.findall('.//package')
          
          comment = "## ðŸ“Š Backend Unit Test Coverage Report\n\n"
          comment += f"**Overall Coverage:** {overall_line_rate:.2f}% (Lines) | {overall_branch_rate:.2f}% (Branches)\n\n"
          comment += "### Coverage by Module\n\n"
          comment += "| Module | Line Coverage | Branch Coverage |\n"
          comment += "|--------|---------------|------------------|\n"
          
          for package in packages:
              for cls in package.findall('.//class'):
                  filename = cls.attrib.get('filename', '')
                  if any(module in filename for module in ['firefighters', 'stations', 'inspections']):
                      line_rate = float(cls.attrib.get('line-rate', 0)) * 100
                      branch_rate = float(cls.attrib.get('branch-rate', 0)) * 100
                      module_name = filename.split('/')[-1].replace('.py', '')
                      
                      # Add emoji based on coverage
                      line_emoji = "âœ…" if line_rate >= 80 else "âš ï¸" if line_rate >= 60 else "âŒ"
                      branch_emoji = "âœ…" if branch_rate >= 80 else "âš ï¸" if branch_rate >= 60 else "âŒ"
                      
                      comment += f"| `{module_name}` | {line_emoji} {line_rate:.2f}% | {branch_emoji} {branch_rate:.2f}% |\n"
          
          comment += "\n### Test Results\n\n"
          comment += "- âœ… All backend unit tests passed\n"
          comment += "- âœ… All Flutter integration tests passed\n"
          comment += "\n---\n"
          comment += f"*Coverage report generated for commit: ${{ github.event.pull_request.head.sha }}*"
          
          # Write to file for GitHub comment
          with open('coverage_comment.txt', 'w') as f:
              f.write(comment)
          
          print(f"Overall Line Coverage: {overall_line_rate:.2f}%")
          print(f"Overall Branch Coverage: {overall_branch_rate:.2f}%")
          EOF
      
      - name: Post coverage comment to PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const coverageComment = fs.readFileSync('coverage_comment.txt', 'utf8');
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ðŸ“Š Backend Unit Test Coverage Report')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: coverageComment
              });
              console.log('Updated existing coverage comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: coverageComment
              });
              console.log('Created new coverage comment');
            }
